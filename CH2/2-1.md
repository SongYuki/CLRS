# Chapter2

插入算法的设计使用的是增量（incremental）方法：在排好子数组A[1..j-1]后，将
元素A[j]插入，形成排好序的子数组A[1..j]
这里需要注意的是由于大部分编程语言的数组都是从0开始算起，这个与伪代码认为
的数组的数是第1个有所不同，一般要注意有几个关键值要比伪代码的小1.

循环不变式(Loop Invariant)是证明算法正确性的一个重要工具。对于循环不变式，
必须证明它的三个性质：
初始化(Initialization)：它在循环的第一轮迭代开始之前，应该是正确的。
保持(Maintenance)：如果在循环的某一次迭代开始之前它是正确的，那么，在下
一次迭代开始之前，它也是正确的。
终止(Termination)：当循环结束时，不变式给了我们一个有用的性质，它有助于表
明算法是正确的。
运用循环不变式对插入排序算法的正确性进行证明：
初始化：j=2，子数组 A[1..j-1]只包含一个元素 A[1],显然它是已排序的。

保持： 若A[1..j-1]是已排序的， 则按照大小确定了插入元素A[j]位置之后的数组A[1..j]
显然也是已排序的。
终止：当 j=n+1 时，退出循环，此时已排序的数组是由 A[1],A[2],A[3]…A[n]组成的
A[1..n]，此即原始数组 A。


**1**.RAM(Random-Access Machine)模型分析通常能够很好地预测实际计算机上的性能，
RAM 计算模型中，指令一条接一条地执行，没有并发操作。RAM 模型中包含了真实计算机
中常见的指令：算术指令（加法、减法、乘法、除法、取余、向下取整、向上取整指令） 、
数据移动指令（装入、存储、复制指令）和控制指令（条件和非条件转移、子程序调用和返
回指令） 。其中每天指令所需时间都为常量。
RAM 模型中的数据类型有整数类型和浮点实数类型。

**2**.算法的运行时间是指在特定输入时，所执行的基本操作数（或步数） 。

**3**.一般考察算法的最坏情况运行时间。这样做的理由有三点：
A．一个算法的最坏情况运行时间是在仸何输入下运行时间的一个上界。
B．对于某些算法，最坏情况出现的是相当频繁的。
C．大致上来看， “平均情况“通常与最坏情况一样差。

**4**.如果一个算法的最坏情况运行时间要比另一个算法的低，我们常常就认为它的效率更高。


**5**.分治法（divide-and-conquer）:有很多算法在结构上是递归的：为了解决一个给定的问
题，算法要一次戒多次地递归调用其自身来解决相关的问题。这些算法通常采用分治策略：
将原问题划分成 n 个规模较小而结构不原问题相似的子问题；递归地解决这些子问题，然后
再合并其结果，就得到原问题的解。
容易确定运行时间，是分治算法的有点之一。

**6**.分治模式在每一层递归上都有三个步骤：
分解（Divide） ：将原问题分解成一系列子问题；
解决（Conquer） ：递归地解各子问题。若子问题足够小，则直接求解；
合并（Combine） ：将子问题的结果合并成原问题的解。

**7**.合并排序（Merge Sort）算法完全依照了分治模式。
分解：将 n 个元素分成各含 n/2 个元素的子序列；
解决：用合并排序法对两个子序列递归地排序；
合并：合并两个已排序的子序列以得到排序结果。
在对子序列排序时，其长度为 1 时递归结束。单个元素被视为是已排好序的。
合并排序的关键步骤在于合并步骤中的合并两个已排序子序列。为做合并，引入一个辅助过
程 MERGE(A,p,q,r)，其中A 是个数组，p、q 和 r 是下标，满足p ≤ q < ?。该过程假设子数
组 A[p..q]和 A[q+1..r]都已排好序，并将他们合并成一个已排好序的子数组代替当前子数组
A[p..r]。
MERGE 过程的时间代价为Θ(n)，其中 n=r-p+1 是待合并的元素个数。

MERGE 过程:
MERGE(A,p,q,r)
1  n1 ← q− p+1
2  n2 ← r −q
3  create arrays L[1..n1 + 1] and R[1..n2 +1]
4  for i ← 1 to n1
5  do L[i]←A[p+i-1]
6  for j←1 to n2
7  do R[j]←A[q+j]
8  L[n 1 + 1]← ∞
9  R[n 2 +1]← ∞
10 i ← 1
11 j ← 1
12 for k ←p to r
13 do if L[i]≤R[j]
14 then A[k]←L[i]
15 i ← i+1
16 else A[k]←R[j]
17 j ← j +1

MERGE 过程正确性的证明
初始化： 第一轮循环， k=p， i=1， j=1， 已排序数组 L、 R， 比较两数组中最小元素 L[i]、 R[j]，
取较小的置于A[p]，此时子数组A[p..p]不仅是已排序的（仅有一个元素） ，而且是所有待排序元素中最小的。若最小元素是L[i]，取 i=i+1，即 i 指向 L 中未排入 A 的所有元素中最小
的一个；同理，j 之于 R 数组也是如此。
保持：若 A[p..k]是已排序的，由计算方法知，L 中 i 所指、R 中 j 所指及其后仸意元素均大
于等于 A[p..k]中最大元素 A[k],当 k=k+1，A[k+1]中存入的是 L[i]、R[j]中较小的一个，但
是仍有 A[k]≤A[k+1]，而此时，子数组A[p..k+1]也必是有序的，i、j 仍是分别指向L、R 中
未排入 A 的所有元素中最小的一个。
终止： k=r+1 时终止跳出循环， 此时， A[p..r]是已排序的， 且显有 A[p]≤A[p+1]≤..≤A[r]。
此即原待排序子数组，故算法正确。

MERGE-SORT(A,p,r)
1  if p<r
2  then q← (p+r)/2
3  MERGE-SORT(A,p,r)
4  MERGE-SORT(A,q+1,r)
5  MERGE-SORT(A,p,q,r)
算法与二叉树的后序遍历算法（先左子树，然后右子树，最后根）相似。
（第三行、第四行顺序可以互换）